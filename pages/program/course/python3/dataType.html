<header>
    六种标准数据类型
</header>
<p>
    Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。
</p>
<p>
    Python3 中有六个标准的数据类型：Number（数字） + String（字符串） + List（列表） + Tuple（元组） + Sets（集合） + Dictionary（字典）。
</p>
<h2>
    Number（数字）
</h2>
<p>
    数字类型是顾名思义是用来存储数值的，需要记住的是，有点和Java的字符串味道差不多，如果改变了数字数据类型的值，将重新分配内存空间。
</p>
<p>
    可以使用del语句删除一些数字对象的引用：del var1[,var2[,var3[....,varN]]]]。
</p>
<p>
    Python 支持三种不同的数值类型：
</p>
<ol>
    <li>
        整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。
    </li>
    <li>
        浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）
    </li>
    <li>
        复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。
    </li>
</ol>
<h3>
    数字类型转换
</h3>
<ul>
    <li>
        int(x) 将x转换为一个整数。
    </li>
    <li>
        float(x) 将x转换到一个浮点数。
    </li>
    <li>
        complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。
    </li>
    <li>
        complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。
    </li>
</ul>
<h2>
    String（字符串）
</h2>
<h3>
    创建字符串
</h3>
<p>
    创建字符串可以使用单引号、双引号、三单引号和三双引号，其中三引号可以多行定义字符串，有点类似ES6中的反引号。
</p>
<p>
    Python 不支持单字符类型，单字符也在Python也是作为一个字符串使用。
</p>
<h3>
    访问字符串中的值
</h3>
<p>
    和ES一样，可以使用方括号来截图字符串，例子如下：
</p>
<pre tag="python">
val_str='zxl20070701'

print(val_str[0]) #z

print(val_str[1:3]) #xl

print(val_str[:3]) #zxl

print(val_str[:5]) #zxl20
</pre>
<h3>
    字符串格式化
</h3>
<pre tag="python">
temp="我叫 %s 今年 %d 岁!" % ('zxl20070701', 7)

print('['+temp+']') #[我叫 zxl20070701 今年 7 岁!]
</pre>
<p>
    如上所示，字符串支持格式化，当然，出来上面用到的%s和%d以外，还有一些别的。
</p>
<p class="warn">
    所有的字符串都是Unicode字符串（针对python3），有很多有用的方法，真的很有ES和C结合体的味道。
</p>
<h2>
    List（列表）
</h2>
<p>
    序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。
</p>
<p>
    Python有6个序列的内置类型（列表、元组、字符串、Unicode字符串、buffer对象和xrange对象）。
</p>
<p>
    列表其实类似数组，具体的一些操作就很像字符串（类似ES中数组和字符串的关系）。
</p>
<h3>
    常见运算
</h3>
<p>
    下面用一个例子来展示一些常见的运算：
</p>
<pre tag="python">
val_arr=['Made','in','China']
del val_arr[1]

print(val_arr) #['Made', 'China']
print(len(val_arr)) #2

val_newarr=val_arr+[':information']

print(val_newarr) #['Made', 'China', ':information']

val_arr=val_arr*2

print(val_arr) #['Made', 'China', 'Made', 'China']
print('in' in val_arr) #False
print('Made' in val_arr) #True

for row in val_newarr:
    print(row, end=" - ") #Made - China - :information -
    
print(val_newarr[-1]) #:information
print(val_newarr[1:]) #['China', ':information']
</pre>
<p>
    再来看一个有用的例子：
</p>
<pre tag="python">
cols=3
rows=2
list_2d = [[0 for col in range(cols)] for row in range(rows)]

print(list_2d) #[[0, 0, 0], [0, 0, 0]]
</pre>
<h3>
    嵌套列表
</h3>
<p>
    使用嵌套列表即在列表里创建其它列表，例如：
</p>
<pre tag="python">
loop_arr=['zxl','20070701']
result_arr=[loop_arr,'同级别']

print(result_arr) #[['zxl', '20070701'], '同级别']
</pre>
<p>
    列表的嵌套就很灵活，此外随便提一下：和前面说的一样，也有很多方法提供高效的开发。
</p>
<h2>
    Tuple（元组）
</h2>
<p>
    元组与列表类似，不同之处在于元组的元素不能修改，元组使用小括号，列表使用方括号。
</p>
<h3>
    创建
</h3>
<p>
    元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用
</p>
<pre tag="python">
tup1 = ('Google', 'Runoob', 1997, 2000)
tup2 = (1, 2, 3, 4, 5 )
tup3 = "a", "b", "c", "d"

print(tup1) #('Google', 'Runoob', 1997, 2000)
print(tup2) #(1, 2, 3, 4, 5)
print(tup3) #('a', 'b', 'c', 'd')
</pre>
<h3>
    基本操作
</h3>
<p>
    和列表的操作很相似，下面说一个几条特殊的地方：
</p>
<ol>
    <li>
        del可以删除某个元组，不过不可以删除元组的某个条目。
    </li>
    <li>
        不可以修改，或许元组会更快，感觉的，没有实际测试。
    </li>
    <li>
        由于元组不可以修改，虽然同样有一些方法，不过和修改相关的方法就没有了。
    </li>
</ol>
<h2>
    Sets（集合）
</h2>
<p>
    回想一下数学里面的集合，合、交、差、补等运算是不是一下子回想起来了，这里的集合也有这些方法。
</p>
<p>
    和Java的集合类似，一个无序不重复元素集（与列表和元组不同，集合是无序的，也无法通过数字进行索引）。
</p>
<h2>
    Dictionary（字典）
</h2>
<p>
    字典是另一种可变容器模型，且可存储任意类型对象。
</p>
<p>
    字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中，键必须是唯一的，但值则不必。
</p>
<p>
    和ES中的JSON的差不多，操作也很像，不过区别也很大，内置方法很多，具体还是一样，看文档去。
</p>
<h3>
    删除字典元素
</h3>
<p>
    可以用del删除一个条目或字典，也可以用clear()方法清空字典（比如现在有字段dict，就是：dict.clear()）。
</p>